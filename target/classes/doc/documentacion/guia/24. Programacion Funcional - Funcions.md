La programación funcional es un paradigma de programación que se enfoca en la evaluación de funciones matemáticas para resolver problemas de programación. En Java, la programación funcional se puede lograr mediante el uso de expresiones lambda, streams y métodos de referencia.

Las expresiones lambda son funciones anónimas que se pueden pasar como argumentos a otros métodos. Se definen utilizando la sintaxis `() -> {}`, donde `()` especifica los parámetros de entrada y `{}` el cuerpo de la función.

Los streams son secuencias de elementos que se pueden procesar en paralelo o en serie. Se pueden utilizar para filtrar, ordenar, transformar y reducir conjuntos de datos. Para crear un stream se utiliza el método `stream()` de una colección.

Los métodos de referencia son una forma de referenciar a un método sin invocarlo. Se definen utilizando la sintaxis `Clase::método`. Por ejemplo, `System.out::println` hace referencia al método `println()` de la clase `System.out`.

A continuación se presenta un ejemplo de cómo utilizar expresiones lambda y streams en Java:

```
import java.util.ArrayList;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>();
        numbers.add(1);
        numbers.add(2);
        numbers.add(3);
        numbers.add(4);
        numbers.add(5);
        
        // Filtrar números pares
        List<Integer> evenNumbers = numbers.stream()
                                            .filter(n -> n % 2 == 0)
                                            .collect(Collectors.toList());
                                            
        // Imprimir los números pares
        evenNumbers.forEach(System.out::println);
    }
}
```

En este ejemplo se crea una lista de números y se utiliza un stream para filtrar los números pares. Luego se utiliza el método `forEach()` para imprimir los números pares.

En Java existen varios tipos de interfaces funcionales que permiten trabajar con programación funcional, entre ellas se pueden mencionar:

1.  `Consumer`: Recibe un argumento y no devuelve ningún valor.
2.  `Function`: Recibe un argumento y devuelve un valor.
3.  `Predicate`: Recibe un argumento y devuelve un valor booleano.
4.  `Supplier`: No recibe argumentos y devuelve un valor.
5.  `UnaryOperator`: Recibe un argumento del mismo tipo y devuelve un valor del mismo tipo.
6.  `BinaryOperator`: Recibe dos argumentos del mismo tipo y devuelve un valor del mismo tipo.

Estas interfaces se encuentran en el paquete `java.util.function` y son utilizadas principalmente en programación funcional, Streams, Lambdas y en el API de Concurrencia de Java.

## Consumers - (foreach)

En Java, `Consumer` es una interfaz funcional que representa una operación que acepta un solo argumento de entrada y no tiene valor de retorno. El objetivo de esta interfaz es realizar algún tipo de operación en el objeto de entrada, como modificarlo o imprimir información sobre él. La firma de la interfaz `Consumer` es la siguiente:

```
@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);
}
```

Aquí, `T` es el tipo del objeto de entrada que se pasará al método `accept`. El método `accept` toma un objeto de tipo `T` como argumento y devuelve `void`. La anotación `@FunctionalInterface` se usa para indicar que esta interfaz es una interfaz funcional, lo que significa que solo tiene un método abstracto (`accept`) y se puede utilizar como el tipo de un objeto lambda.

A continuación, se muestra un ejemplo simple de cómo se puede usar la interfaz `Consumer` para imprimir información sobre un objeto:

```
import java.util.function.Consumer;

public class Main {
    public static void main(String[] args) {
        Consumer<String> printString = s -> System.out.println(s);
        printString.accept("Hola, mundo!");
    }
}
```

En este ejemplo, se crea un objeto `Consumer` llamado `printString` que acepta un objeto de tipo `String` y lo imprime en la consola. Luego, se llama al método `accept` del objeto `printString` con el argumento `"Hola, mundo!"`, lo que imprime `"Hola, mundo!"` en la consola.

## Function - (map)

La interfaz funcional `Function` es una de las interfaces más utilizadas en la programación funcional de Java. Representa una función que acepta un argumento de un tipo y devuelve un resultado de otro tipo.

La interfaz Function tiene un solo método abstracto llamado `apply()`, que toma un argumento del tipo especificado y devuelve un resultado del tipo especificado. La sintaxis básica de la interfaz es la siguiente:

```
public interface Function<T, R> {
    R apply(T t);
}
```

Donde:

-   `T` es el tipo de entrada del argumento.
-   `R` es el tipo de salida o resultado.

Esta interfaz se puede usar para representar cualquier función que tome un objeto de un tipo y lo convierta en otro objeto de un tipo diferente. Algunos ejemplos de cómo se puede usar la interfaz Function son:

```
Function<String, Integer> stringToInt = Integer::valueOf;
Function<Integer, Integer> doubleInt = x -> x * 2;
Function<Integer, String> intToString = Object::toString;
```

En el primer ejemplo, se crea una función que convierte una cadena en un entero utilizando el método `valueOf()` de la clase `Integer`. En el segundo ejemplo, se crea una función que toma un entero y devuelve el doble del valor. En el tercer ejemplo, se crea una función que convierte un entero en una cadena utilizando el método `toString()` de la clase `Object`.

La interfaz Function es muy útil en situaciones en las que se necesita realizar una operación en una colección de objetos y se desea transformar esos objetos en otros objetos. Por ejemplo, se puede utilizar para transformar una lista de cadenas en una lista de enteros, o para transformar una lista de objetos de un tipo en una lista de objetos de otro tipo.

## Predicate - (filter)

La interfaz funcional `Predicate<T>` es una de las interfaces de la API de programación funcional de Java. Esta interfaz representa una función que toma un argumento de tipo `T` y devuelve un valor booleano.

La declaración de la interfaz `Predicate<T>` es la siguiente:

```
@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);
}
```

La anotación `@FunctionalInterface` indica que la interfaz tiene exactamente un método abstracto que debe ser implementado.

El único método en la interfaz es `test(T t)`, que toma un argumento de tipo `T` y devuelve un valor booleano. Este método es utilizado para evaluar una condición sobre el objeto de tipo `T`. Si la condición se cumple, el método devuelve `true`; de lo contrario, devuelve `false`.

La interfaz `Predicate<T>` es comúnmente utilizada en combinación con otras interfaces funcionales, como `Function<T, R>` y `Consumer<T>`, para procesar colecciones de objetos.

Aquí hay un ejemplo de cómo se podría utilizar la interfaz `Predicate<T>` para filtrar una lista de cadenas de texto:

```
List<String> nombres = Arrays.asList("Juan", "Pedro", "Ana", "Luisa", "Maria");

// Crear un Predicate para evaluar si una cadena tiene longitud 4
Predicate<String> filtro = s -> s.length() == 4;

// Filtrar la lista utilizando el Predicate
List<String> nombresFiltrados = nombres.stream()
                                       .filter(filtro)
                                       .collect(Collectors.toList());

System.out.println(nombresFiltrados); // Output: [Juan, Ana]
```

En este ejemplo, se crea un `Predicate` que evalúa si una cadena tiene longitud 4. Luego, se utiliza este `Predicate` para filtrar una lista de nombres utilizando el método `filter` de `Stream`. El resultado es una lista que contiene los nombres que cumplen la condición del `Predicate`.

## Supplier - ()

La interfaz funcional `Supplier<T>` es una de las interfaces predefinidas en Java que forma parte del paquete `java.util.function`. Esta interfaz define un método abstracto `get()` que no toma ningún argumento y devuelve un resultado de tipo `T`. En otras palabras, la interfaz `Supplier<T>` representa una operación que no toma ningún argumento y devuelve un resultado de tipo `T`.

El uso principal de la interfaz `Supplier<T>` es en la programación de expresiones lambda y la programación funcional. Algunos casos de uso comunes para esta interfaz son la generación de valores aleatorios, la obtención de una fecha o una hora actual, o la creación de instancias de objetos.

Aquí hay un ejemplo de cómo se puede utilizar la interfaz `Supplier<T>`:

```
import java.util.function.Supplier;

public class Example {

  public static void main(String[] args) {

    // Crear un objeto de tipo Supplier que genere un número aleatorio entre 1 y 100
    Supplier<Integer> randomNumberSupplier = () -> (int) (Math.random() * 100) + 1;

    // Obtener un número aleatorio
    int randomNumber = randomNumberSupplier.get();

    System.out.println("Número aleatorio: " + randomNumber);
  }
}
```

En este ejemplo, creamos un objeto de tipo `Supplier<Integer>` que genera un número aleatorio entre 1 y 100 cada vez que se llama a su método `get()`. Luego, llamamos al método `get()` para obtener un número aleatorio y lo imprimimos en la consola.

## UnaryOperator